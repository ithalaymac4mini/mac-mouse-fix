//
// --------------------------------------------------------------------------
// MFDataClass.m
// Created for Mac Mouse Fix (https://github.com/noah-nuebling/mac-mouse-fix)
// Created by Noah Nuebling in 2024
// Licensed under Licensed under the MMF License (https://github.com/noah-nuebling/mac-mouse-fix/blob/master/License)
// --------------------------------------------------------------------------
//

#import "MFDataClass.h"
@import ObjectiveC.runtime;
#import "MFPlistDecoder.h"
#import "EventLoggerForBradMacros.h"
#import "NSCoderErrors.h"
#import "MFCoding.h"
#import "TreeNode.h"

#import "NSCharacterSet+Additions.h"

@implementation MFDataClassBase

/// General Notes:
/// Notes on handling primitive properties:
///     The KVC API (`valueForKey:` and `setValue:forKey`) automatically wraps (and unwraps) numbers and structs in `NSNumber` or `NSValue` objects.
///         Source: Apple Docs: KeyValueCoding - Representing Non-Object Values: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE
///     `NSValue` (and its subclass `NSNumber`) also adopt the `NSCopying` and `NSSecureCoding` protocols. On top of this, NSValue also implements the`hash` and `isEqual:`methods in a proper way (and it works even if you box custom structs - From my limited testing).
///     -> Because of this, we don't need much primitive-value-specific code - NSValue and KVC does it all for us!
///         (Where 'primitive-value' refers to any non-object value that KVC is compatible with, such as c numbers and structs. Other c types like unions don't work with KVC I heard, and therefore might break `MFDataClass`.) (Update: We now validate inside +load that there are no unions and stuff.)

// MARK: (Almost) compile time validation

+ (void)onLoadValidation {
    
    /// Validate definition of this MFDataClass
    ///     Ideally we'd be able to do this validation while, or even before compilation. But that's not possible, so doing it in `+ load` in DEBUG builds is the next best thing.
    ///     Notes:
    ///     - We invoking this in `+ load` in the code generated by the `MFDataClassImplementX()` macros.
    ///     - We're using `#if DEBUG` instead of `runningPrerelease()` because I'm not sure that would slow down app start time in release builds. (Should maybe test this). Also I think `#if DEBUG` is enough since this should catch any issues with MFDataClass definitions every time the app launches, so I don't ever need to ship this to users to catch issues.
    ///     - We're using `[NSException raise]` because that seems to be the only way to crash the program while writing a message into the crashReport. (Update: Why is that important though?) I also heard about a technique using the `__crashreporter_info__` global var but haven't looked into it much.
    ///             Update: In the CFRelease() source code I saw CRSetCrashLogMessage(). Could we use that?
    ///             Sidenote: The CFRelease() source code contains a really interesting method for detecting recursion: Taking the address of goto-labels and comparing them to `__builtin_return_address(0)`.  (I used NSThread dicts when I needed to detect recursion which might be much slower –– But I also saw there's the `static __thread` storage modifier for more lightweight thread-local storage.)
    ///     - Should/could we validate against somebody trying to subclass an MFDataClass without using the MFDataClassX() macros? That might be possible by having [MFDataClassBase +load] find and iterate all its subclasses and then applying this validation. But since I'm working on this project alone, I won't make that mistake.
    
    #if DEBUG
    
    /// Log
    NSLog(@"Validating MFDataClass: %@", self); /// Using NSLog since I don't know if DDLog works in `+ load`.
    
    /// Validate superclass
    
    Class superclass = class_getSuperclass([self class]);
    if (!isclass(superclass, MFDataClassBase)) {
        [NSException raise:MFDataClassInvalidDefinitionException format:@"MFDataClass '%@' does not seem to inherit from MFDataClassBase. Superclass is '%@'.", self, superclass];
    }
    Class classToCheck = superclass;
    while (true) {
        
        /// Get propertyCount
        unsigned int propertyCount;
        free(class_copyPropertyList(classToCheck, &propertyCount));
        
        /// Validate
        if (propertyCount > 0) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"MFDataClass '%@' inherits from a class with more than 0 properties (%@). This would break the autogenerated initializers. Compose MFDataClass instances together into nested structures instead of inheriting from an MFDataClass with more than 0 properties.", self, classToCheck];
        }
        
        /// Break
        if (classToCheck == MFDataClassBase.class) { break; } /// Found MFDataClassBase
        if (classToCheck == nil || classToCheck == NSObject.class) { assert(false); break; } /// Found root class, this can never happen (as of Oct 2024)
        
        /// Iterate
        classToCheck = class_getSuperclass(classToCheck);
        
    }
    
    /// Validate properties
    for (NSString *propertyName in self.allPropertyNames) {

        /// Get typeEncoding
        NSString *propertyAttributes = [self attributesForProperty:propertyName];
        NSString *typeEncoding = typeEncodingForProperty(propertyAttributes);
        if (typeEncoding == nil) {
            [NSException raise:NSInternalInconsistencyException format:@"Couldn't get type encoding for property %@.%@ with attributes %@ (This should never happen, no matter how the MFDataClass is defined.)", self, propertyName, propertyAttributes];
        }
        
        /// Validate nullable/nonnull property attribute
        ///     Keep in mind: (Oct 2024)
        ///         This validates the nullability that's passed into the `@implementation` macro (`MFDataClassImplementX()`)
        ///         But meanwhile, all the native objc warnings as well as the way that the dataclass is imported into Swift depends on the nullability specified in the `@@interface` macro (`MFDataClassInterfaceX()`)
        ///         -> ! Keep the nullability in the `@@implementation` and `@@interface` macros synchronized!
        ///             ... otherwise, these validations here won't ensure correctness.
        BOOL isNullableType = propertyHasTypeThatSupportsNullability(typeEncoding);
        NSString *rawNullability = [self rawNullabilityAndTypeOfProperty:propertyName][0];
        if (rawNullability == nil) {
            [NSException raise:NSInternalInconsistencyException format:@"Raw nullability string of property %@.%@ was nil. (This should never happen, no matter how the MFDataClass is defined.)", self, propertyName];
        }
        if (isNullableType && ([rawNullability isEqual:@""] || [rawNullability isEqual:@"null_unspecified"])) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has unspecified nullability (raw nullability value: '%@') even though its type supports nullability. Due to the existence of NS_ASSUME_NONNULL, we cannot know at runtime whether the property is nullable or not if nullability is not specified. This could (theoretically) lead to bugs and inconsistencies because we won't be able to validate nullability inside `initWithCoder:`. Please explicitly specify the nullability in the MFDataClass definition to fix this.", self, propertyName, rawNullability];
        } else if (!isNullableType && ![rawNullability isEqual:@""]) {
            [NSException raise:NSInternalInconsistencyException format:@"Property %@.%@ has specified nullability even though its type does not support nullability. This should never happen (since the objc compiler doesn't even let you compile when you do this afaik)", self, propertyName];
        }
        if ([rawNullability isEqual:@"null_resettable"]) {
            [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has null_resettable attribute. Don't know how to handle this. Needs additional testing.", self, propertyName];
        }
        
        /// Note: We don't need to validate the readwrite/readonly property attribute since there's nothing to do wrong there.
        /// Note: We don't need to validate the assign/strong/weak/copy property attributesince the objc compiler already validates the necessary stuff (objc doesn't let you use assign with objects, but forces you to use assign with non-objects)
        
        /// Validate property type
        NSString *propClassName = classNameForProperty([typeEncoding cStringUsingEncoding:NSUTF8StringEncoding]);
        
        if (propClassName != nil) {
            
            /// Property is an object
            if ([propClassName isEqual:@"id"]) { /// Our `classNameForProperty:` returns `id` to signal that the className is unspecified.
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ has an unspecified class type (likely declared using `id`.) Use a concrete class like `NSObject` instead. Otherwise we can't run type validation when decoding an instance of this object, and so we cannot decode using NSSecureCoding.", self, propertyName];
            }
            
            Class theClass = NSClassFromString(propClassName);
            if (theClass == nil) {
                [NSException raise:NSInternalInconsistencyException format:@"Failed to instantiate class for property %@.%@. propertyAttributes: %@, className: %@. Not sure if this can ever happen.", self, propertyName, propertyAttributes, propClassName];
            }
            
            NSArray<Protocol *> *protocols = @[@protocol(NSSecureCoding),
                                               @protocol(NSCopying),
                                               @protocol(NSObject)]; /// We can't really confirm that the object properly implements `isEqual:` since that's part of the `NSObject` protocol which everybody implements;
            
            for (Protocol *protocol in protocols) {
                if (![theClass conformsToProtocol:protocol]) {
                    [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with class %@ does not conform to protocol: %@. This would silently break protocol conformance of the MFDataClass (%@). Please use another type for the property.", self, propertyName, propClassName, protocol, self];
                }
            }
            
        } else {
        
            /// Property is non-object-type
            ///     -> Check if we know how to handle this type
            ///     -> What we reallyyy want to know is whether Key-Value-Coding will auto-box these types in NSValue. If that's the case everything should work.
            ///         (Because NSValue adopts all the protocols we want: `NSSecureCoding`, `NSCopying`, `NSObject`)
            ///         -> However, I don't know how to check exactly which types will get autoboxed in NSValue. So these tests are kinda based on my gut feeling and stuff.
            ///
            ///     Documentation of c-type encodings:
            ///         1.NSHipster:  https://nshipster.com/type-encodings/
            ///         2. Apple Docs: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1
            
            ///     Note that we're disallowing many c types
            ///         ... but we let any **structs** and **numbers** pass.
            ///         Numbers should always work. (They're always auto-boxed in `NSNumber` by KVC)
            ///         Structs are normally auto-boxed by KVC. But I suspect that some complex structs with won't be supported? I don't know how to check that, though.
            
            /// Remove the leading 'const' encoding (r)
            ///     Observation: const is only encoded for some types it seems.
            ///     I saw r be part of the objc encoding of `const char *` (which is `r*`). But for `const NSString *`, const seems to be ignored in the type encoding. Didn't test how `const int` is encoded.
            if ([typeEncoding characterAtIndex:0] == 'r') typeEncoding = [typeEncoding substringFromIndex:1];
            
            /// Extract chars
            unichar chars[typeEncoding.length];
            [typeEncoding getCharacters:chars];
            
            if ([typeEncoding isEqual:@"@?"]) { /// block ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a block pointer.   Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding isEqual:@"^?"]) { /// function ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a function ptr.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if ([typeEncoding isEqual:@"^v"]) { /// void ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a void pointer.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '^') { /// any ptr
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a raw pointer.     Not sure how to handle that", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '(') { /// union
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a union.           They are incompatible with KVC afaik.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '[') { /// c array
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a c array.         Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '*') { /// c string
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a raw c string.    Not sure how to handle that. Probably use NSString instead.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == 'b') { /// bit field
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a bit field.       Not sure how to handle that", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '#') { /// Class object
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a class object.    Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == ':') { /// SEL
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be a SEL.             Not sure how to handle that.", self, propertyName, typeEncoding];
            
            } else if (chars[0] == '?') { /// Unknown
                [NSException raise:MFDataClassInvalidDefinitionException format:@"Property %@.%@ with typeEncoding %@ seems to be 'unknown'.         Not sure how to handle that.", self, propertyName, typeEncoding];
            }
        }
    }
    
    #endif
}

// - MARK: Protocol implementations

// MARK: NSSecureCoding protocol

+ (BOOL) supportsSecureCoding {
    /// I think we only support secureCoding if all properties have types that also conform to `NSSecureCoding`? Not sure what happens if this is not the case. But I thinkkk it would just fail gracefully, and still work when we turn `.requiresSecureCoding` off.
    ///     Update: In +load we now do validation that properties support `NSSecureCoding`.
    return YES;
}

- (void) encodeWithCoder: (NSCoder *)coder { /// You don't call these encoding/decoding methods directly, instead you use an NSCoder subclass or (`MFEncode()` / `MFDecode()`)
    for (NSString *key in self.class.allPropertyNames) {
        id value = [self valueForKey: key];
        [coder encodeObject: value forKey: key]; /// We also encode nil values.
    }
}

/// Helper macros for decoding failures
///     Explanation: See MFCoding.m NSCoderErrors.m

#define failWithError(code_, messageAndFormatArgs...) ({                               \
    [coder failWithError:MFNSCoderErrorMake((code_), stringf(messageAndFormatArgs))];  \
    return nil;                                                                        \
})

- (instancetype) initWithCoder: (NSCoder *)coder {
    
    /// Also see: MFCoding.m for explanation of relevant concepts.
    ///
    /// Here, we're implementing **autogenerated validation** for decoded values.
    ///     As discussed inside MFCoding.m, validation of decoded values is not a solution for any problem except when the archives are coming from an *untrusted source*. When that is the case, these autogenerated validations are *not enough* to actually ensure security.
    ///     The automated validations might improve robustness a bit (in case of hacker-attacks or in case of trying to decode an outdated archive.). But they shouldn't be relied on for anything.
    ///     If you really need protections against hacker attacks, implement **custom validation**. If you need to handle outdated archives, implement **versioning** -> This is explained in detail in MFCoding.m
    ///
    ///     (Sidenote: You turn on validations by setting coder.requiresSecureCoding = YES)
    ///
    /// What exactly does the **autogenerated validation** here do?
    ///     We do all of the validations that are feasible to do automatically, given the declaration of the MFDataClass:
    ///     We validate:            (as of [Feb 2025])
    ///         1. That the coder contains a key for each property name
    ///         2. That the decoded value is not nil, unless the property is declared as `nullable`.
    ///         3. That the type of the decoded value matches the type signature of the property.
    ///             - For lightweight generics, the exact structure of the decoded object-tree isn't validated. E.g. if the property's type is (`NSDictionary<NSString *, NSNumber *> *`) but we decode
    ///                 a dict with swapped key and value-types (`NSDictionary<NSNumber *, NSString *> *`), then this method will *not* fail the decode. If you need that validation, you need to implement *custom validation*.
    ///
    ///         > If any of these validations fail, the entire decode fails.
    ///
    /// How to implement **custom validation**?
    ///     > Basically, override this method (-initWithCoder:) in a MFDataClass category.
    ///     Implementation tips:
    ///         - On KVC boxing:
    ///             Be wary that [MFDataClassBase initWithCoder:] and [MFDataClassBase encodeWithCoder:] uses KVC to get/set property values, which auto-boxes/unboxes all non-object values.
    ///             Speculation: NSCoder methods like [NSCoder decodeIntForKey:] might be used to conveniently unbox values, but I haven't tested that.
    ///         - In your implementation, call [super initWithCoder:] to reuse and extend the default validation. (duh)
    ///     Discussion: Why the boilerplate of overriding -[initWithCoder:] entirely?
    ///             We could instead have an overrideable -validateValue:forProperty: method (Or the standard KVC method -validateValue:forKey:error: ?) – and have that be called by -initWithCoder:
    ///             However, I think simply overriding -initWithCoder: is less annoying and more flexible due to the "allowedClasses" shenanigans that NSSecureCoding requires.
    
    self = [super init];
    if (!self) return nil;
    
    for (NSString *key in self.class.allPropertyNames) {
    
        if (!coder.requiresSecureCoding) {
            
            /// Non-secure decoding
            ///  -> Do absolutely no validation -> Should be a bit faster. Can't think of other reasons to use this. Not sure the speed ever matters. (But not sure the 'security' ever matters for us either. Read more in MFCoding.m)
            id _Nullable value = [coder decodeObjectForKey: key];
            
            /// Store the decoded value inside the self.key property
            [self setValue: value forKey: key];
        }
        
        else if (coder.requiresSecureCoding) {
        
            /// Validated/"secure" decoding

            /// Guard valueNotFound
            if (![coder containsValueForKey:key]) {
                assert(false);
                failWithError(NSCoderValueNotFoundError, @"No value found for key while decoding %@.%@", [self class], key);
            }
            
            /// Get typeinfo for the self.key property
            NSString *typeEncoding;     /// The type of the self.key property
            BOOL isNonObjectValue = 0;  /// Whether self.key is an object or of primitive type. || Initializing this to silence compiler warnings (which don't make sense)
            Class expectedClass;        /// The class of the object we're expecting to retrieve from the archive for "key"
            
            ({
                
                /// Get typeEncoding
                NSString *propertyAttributes = [[self class] attributesForProperty: key];
                typeEncoding = typeEncodingForProperty(propertyAttributes);
                
                /// Guard no typeEncoding
                ///     Note: We already validate this in the onLoadValidation -> Remove this.
                if (typeEncoding == nil) {
                    assert(false);
                    failWithError(kMFNSCoderError_InternalInconsistency, @"Internal inconsistency: Couldn't get typeEncoding for property %@.%@ with attributes: %@", [self class], key, propertyAttributes);
                }
                
                /// Get className
                NSString *className = classNameForProperty([typeEncoding cStringUsingEncoding: NSUTF8StringEncoding]);
                
                /// Edge case: unspecified object type
                ///     If the property is declared with an unspecified object type, then our type validation code won't work.
                ///     We're already validating this in `+ load` - so this should never happen.
                ///     Note: We already validate this in the onLoadValidation -> Remove this.
                if ((0)) {
                    if ([className isEqual:@"id"]) {
                        assert(false);
                        failWithError(kMFNSCoderError_InternalInconsistency, @"Internal inconsistency: Property %@.%@ with attributes: %@ seems to have unspecified object type (likely declared with `id`).", [self class], key, propertyAttributes);
                    }
                }
                
                /// Parse className
                isNonObjectValue = className == nil; /// If the className is nil, that means the property is a non-object value - that's how our `classNameForProperty()` function works.
                
                /// Get expectedClass
                if (isNonObjectValue)  {
                    expectedClass = [NSValue class]; /// Non-object values come out of our decoder boxed inside an NSValue (That's because when *en*coding an MFDataClass instance, we use the KVC API to get the property values, and this API auto-boxes non-object values in `NSValue`, and so that's how we pass them into the encoder.)
                } else {
                    expectedClass = NSClassFromString(className);
                }
            });
            
            /// Get allowed classes for "secure" decoding
            NSMutableSet<Class> *allowedClasses = [[NSMutableSet alloc] initWithObjects: expectedClass, nil];
            if (!isNonObjectValue) {
                /// Get additional typeinfo about lightweight generics from raw type string
                NSSet<Class> *additionalClasses = [self.class classesFromRawTypeStringOfProperty: key];
                [allowedClasses unionSet: additionalClasses];
            }
            
            /// Recurse / decode value
            ///     (Using NSSecureCoding method)
            ///     The decoder will `failWithError:` automatically, if there's a type mismatch or the decoded object does not implement `NSSecureCoding`.
            ///     -> That is, if `coder.requiresSecureCoding == true`
            ///     -> If `coder.requiresSecureCoding == false` then this would do no checks while decoding the object. `allowedClasses` would be ignored.
            
            id _Nullable value = [coder decodeObjectOfClasses: allowedClasses forKey: key];
            
            /// Propagate decoding error
            ///     Depending on the `coder.decodingFailurePolicy`, `decodeObjectOfClass:` might either throw and error or just set `coder.error` and then return, so we check for that here.
            if (coder.error != nil) {
                assert(false);
                return nil; /// We don't need to call `failWithError()` since the coder already has an error.
            }
            
            /// Check if value is of 'expectedClass'
            ///     -decodeObjectOfClasses:key: already validates something similar. But this is helpful in case the 'hierarchy' of classes in the decoded value is unexpected.
            ///     E.g. If we expect a dictionary of arrays but we get an array of dictionaries, this check would catch it.
            ///     However, this only validates the top-level type. if an unexpected type occurs deeper in the decoded value, then this won't help. E.g. if we expect a dictionary of arrays but get a dictionary of dictionaries this won't catch it.
            ///         To handle that, we'd have to more closely analyze the syntax tree that the -classesFromRawTypeStringOfProperty: result is based on. Learn more in that implementation.
            if (allowedClasses.count > 1) {
                if (value != nil && !isclass(value, expectedClass)) {
                    assert(false);
                    failWithError(NSCoderReadCorruptError, @"Class mismatch while decoding %@.%@: Expected: %@. Found: %@", [self class], key, expectedClass, [value class]);
                }
            }
            
            /// Get nullability
            BOOL isAllowedToBeNil = [[self class] propertyIsAllowedToBeNil: key];
            
            if ((value == nil) && !isAllowedToBeNil) {
                assert(false);
                failWithError(NSCoderReadCorruptError, @"Unexpectedly found nil while decoding non-nullable property %@.%@.", [self class], key);
            }
            
            /// Check boxed type
            if (isNonObjectValue) {
                
                /// Cast to NSValue
                NSValue *nsValue = (NSValue *)value;

                /// Get type encodings
                const char *propertyTypeEncoding = [typeEncoding cStringUsingEncoding: NSUTF8StringEncoding]; /// Why are we boxing here? Perhaps we should handle all these type encoding strings as `const char *` instead of boxing/converting them back and forth? Or use NSSimpleCString as a more lightweight wrapper? ... Eh benchmark first before optimizing though.
                const char *nsValueTypeEncoding = [nsValue objCType];
                
                /// Special case: Booleans
                ///     For boolean properties, the decoded NSValue seems to just use 'c' (char) while the property encoding uses 'B' (boolean). I also checked `ivar_getTypeEncoding()` and it's also `B` so won't help.
                ///     Possible explanation: This KVC doc says that BOOL is char on macOS for historical reasons: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/DataTypes.html#//apple_ref/doc/uid/20002171-BAJEAIEE
                if (strcmp(propertyTypeEncoding, "B") == 0) {
                    propertyTypeEncoding = "c";
                }
                #if !TARGET_OS_OSX
                static_assert(false, "Our bool code probably only handles macOS");
                #endif
                
                /// Check if types match
                if (strcmp(nsValueTypeEncoding, propertyTypeEncoding) != 0) {
                    assert(false);
                    failWithError(NSCoderReadCorruptError, @"Type mismatch while decoding non-object property %@.%@. Expected: %s. Found: %s", [self class], key, propertyTypeEncoding, nsValueTypeEncoding);
                }
            }
            
            /// Passed all validations!
            ///     > Store the decoded value inside the self.key property
            ///     Note that this is a KVC function which will automatically unbox the value (if it's an NSValue)
            [self setValue: value forKey: key];
            
        }   /// End of `if (coder.requiresSecureCoding)`
    
    } /// End of self.class.allPropertyNames iteration
    
    return self;
}

// MARK: NSCopying Protocol
- (id) copyWithZone: (NSZone *)zone {
    
    /// Notes:
    /// - By copying all properties, we do a 'deeper' copy than e.g. `[NSArray -copy]`.
    ///     Perhaps we can rationalize this by thinking: MFDataClass is like an "object-version" of a struct. Structs behave like they are 'deep-copying', so MFDataClass should, as well. (Althouth we're only copying 1 layer deep) Also, shallow copying and then swapping / adding some members to the copy feels more useful on NSArray, since it's a 'more dynamic' datatype (?)
    /// - [Oct 2024] Immutable values can just return themselves instead of a copy and noone will notice. Could we determine whether we are immutable and leverage that for optimization? (We probably could by checking `property_getAttributes()` for whether all our properties are `readonly`.) (But what if the props themselves are mutable?)

    MFDataClassBase *copy = [[[self class] allocWithZone: zone] init];
    if (copy) {
        for (NSString *key in self.class.allPropertyNames) {
            id value = [self valueForKey:key];
            if (value) {
                [copy setValue: [value copyWithZone: zone] forKey: key]; /// Non-object-specific logic is not necessary, since `NSValue` and `NSNumber` (which our non-object values will be boxed in by KVC) adopt the `NSCopying` protocol. But also, NSNumber and NSValue are immutable so `- copyWithZone:` might just `return self` and not do anything and not cause any overhead?
            }
        }
    }
    return copy;
}

// MARK: Override NSObject Equality/Hashing methods:
- (BOOL) isEqual: (id)object {
    
    /// Trivial cases
    if (object == nil) {
        return NO;
    }
    if (self == object) {
        return YES;
    }
    if (object_getClass(self) != object_getClass(object)) { /// Note: Is this a valid way to compare class-equality? TODO: Check our Swizzling code to see how we do it there.
        return NO;
    }
    
    /// Unwrap other
    MFDataClassBase *other = (MFDataClassBase *)object;
        
    /// Compare hash
    ///     Disabling because: At best this would be an optimization, but i think it might slow things down here. Also if the class matches, we already know the hash matches, since the hash is independent of internal object state (As of Nov 2024)
    if ((0) &&
        [self hash] != [other hash])
    {
        return NO;
    }
    
    /// Compare internal state
    if (![self.internalStateForEqualityComparison isEqual:other.internalStateForEqualityComparison]) {
        return NO;
    }
    
    /// Passed all tests!
    return YES;
}
- (NSObject *_Nonnull) internalStateForEqualityComparison {

    /// Client code can override this (in a category) to easily change the definition of equality between two instances of the same MFDataClass
    ///     On nil:
    ///         If you override this with an NSArray of propertyValues, don't forget to substitute nil values with `[NSNull null]`. Trying to insert nil into an array will crash and stuff!
    ///
    ///     Background: (Nov 2024)
    ///         We made this method primarily so we have one simple way to update both `-isEqual` and `-hash` correctly.
    ///         However, we've since made `-hash` independent of internal instance state, so this doesn't affect `-hash` anymore.
    ///         Therefore, now, it might be better to just override `-isEqual` directly instead of overriding this? Maybe we should remove this?
    ///         Idea: Maybe we could replace this with an easily overridable `isEqualToDataClass:` method, which compares internal state and which is called by `isEqual:` (similar to NSString's `isEqualToString:`)
    
    return [self allPropertyValues];
}

- (NSUInteger) hash {

    /// Why use propertyCount as -hash?
    ///     - `-hash` needs to not change while an object is in a collection. For mutable objects, this can only be achieved by a) not putting them into collections b) making hash independent of the mutable internal state of the object.
    ///         - Src: `-hash` docs: https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418859-hash
    ///     - NSDictionary also simply uses the number of elements as its hash. So this should be ok.
    ///
    /// If you need a real hash:
    ///     (... that depends on the instance's internal state), you can encode the instance to data and then use Apple's crypto frameworks.

    NSUInteger propertyCount = [[[self class] allPropertyNames] count];
    return propertyCount;
}

/// MARK: Override NSObject description

- (NSString *) description {

    NSString *content = @"";
    NSArray<NSString *> *propNames = [self.class allPropertyNames];
    if (propNames.count > 0) {
    
        /// Check for circular refs
        ///     This prevents infinite loops if there are circular references in the datastructure. But [NSDictionary -description] seems to just infinite-loop in this case... Maybe this was overkill.
        NSMutableArray *visitedObjects = threadobject([[NSMutableArray alloc] init]);
        NSNumber *s = @((uintptr_t)self); /// We cast self to an NSNumber so that we effectively do pointer-based equality checking instead of using the full `-isEqual` implementation.
        BOOL didFindCircularRef = [visitedObjects containsObject: s];
        [visitedObjects addObject: s];
        MFDefer ^{
            assert([[visitedObjects lastObject] isEqual: s]);
            [visitedObjects removeLastObject];
        };
        
        /// Get description of props
        if ((0)) {
            content = [self asPlistWithRequireSecureCoding: NO].description;
        } else if (didFindCircularRef) {
            content = @"<This object has appeared in the description before. Stopping here to prevent infinite recursion.>";
        } else {
            NSMutableString *_content = [NSMutableString string];
            
            for (int i = 0; i < propNames.count; i++) {
                NSString *name = propNames[i];
                NSString *_Nullable value = [[self valueForKey: name] description]; /// If this is nil, NSString will just insert "(null)" iirc || `-description` is the recursive call that might cause infinite loops if there are circular refs
                [_content appendFormat:@"%@: %@", name, value];
                bool isNotLast = (i < propNames.count - 1);
                if (isNotLast) {
                    [_content appendString:@"\n"];
                }
            }
            content = _content;
        }
    }
    
        
    /// Assemble result
    __auto_type addIndent = ^NSString * (NSString *input) {
        return [input stringByReplacingOccurrencesOfString:@"(^|\n)(.)" /// Match the string start (`^`) and line breaks (`\n`) if they're followed by at least one character (`.`) (That way we skip empty lines)      (General regex explanation: Parentheses `(...)` create a 'capture group')
                                                withString:@"$1    $2"  /// Insert spaces between 1: the string-start / line break (`\n|^`) and 2: the first character of the line (`.`)                                                   (General regex explanation: `$2` is a 'backreference' to the 2nd 'capture group')
                                                   options:NSRegularExpressionSearch
                                                     range:NSMakeRange(0, input.length)];
    };
    
    NSString *result;
    if ([content containsString:@"\n"]) {
        result = stringf(@"<%@> {\n%@\n}", NSStringFromClass(self.class), addIndent(content));
    } else {
        result = stringf(@"<%@> {%@}", NSStringFromClass(self.class), content);
    }
    
    /// Return
    return result;
}

/// MARK: Utility
+ (NSArray<NSString *> *_Nonnull) allPropertyNames {
    
    /// Notes:
    /// - On caching:
    ///     This is used by almost all other methods - We could maybe do some caching here to speed things up
    ///     But don't forget: If we do a naive cache and just return the same NSArray every time, then this will break if properties are added at runtime.
    ///     (Update: [Feb 2025] I'm pretty sure we never ever wanna add properties at runtime to an MFDataClass. Perhaps we would use `objc_setAssociatedObject()` to do something similar.)
    
    /// Create cache
    NSCache *cache = staticobject([[NSCache alloc] init]);
    NSString *cacheKey = [self className];
    
    /// Retrieve cache
    id resultFromCache = [cache objectForKey: cacheKey]; /// NSCache is thread-safe
    if (resultFromCache) return resultFromCache;
    
    /// Calculate fresh
    NSMutableArray *result = [NSMutableArray array];
    ({
        unsigned int propertyCount, i;
        objc_property_t *properties = class_copyPropertyList([self class], &propertyCount);
        MFDefer ^{ free(properties); };
        
        for (i = 0; i < propertyCount; i++) {
            const char *propName = property_getName(properties[i]);
            if (propName) [result addObject: @(propName)]; /// Converting to NSString every time might be a bit slow? ... Update: now we got a cache!
        }
    });
    
    /// Store cache
    [cache setObject: result forKey: cacheKey];
    
    /// Return
    return result;
}

- (NSArray<id> *_Nonnull) allPropertyValues {

    ///     On property order: (Nov 2024)
    ///         The order of these property values needs to always be the same, otherwise `-isEqual:` will break.
    ///         I think it should be fine since the underlying function `class_copyPropertyList()` seems to output the properties in deterministic order based on my testing.
    ///         If order ever does cause breakage, perhaps we could sort the propertyValues or change our `-isEqual:` logic.
    
    NSMutableArray *result = [NSMutableArray array];
    
    for (NSString *propertyName in self.class.allPropertyNames) {
        id propertyValue = [self valueForKey: propertyName];
        propertyValue = propertyValue ?: [NSNull null]; /// Adding nil into an array causes an exception!
        [result addObject: propertyValue];
    }
    
    return result;
}

/// MARK: - Property analysis
///     We use this for validation in `- initWithCoder:`
///     Big picture: (As of Oct 2024)
///         Here, we implement functions to analyze **nullability** and **type** of a property.
///         This is quite a bit of code, but it is really only really used for validation of the decoded data inside `initWithCoder:`
///         - but this validation might not even be helpful in practise -> See discussion inside `initWithCoder:` for more.
///     Sidenote:
///         (We're technically also using this property analysis stuff inside the `+ load` validation, but the `+ load` validation just validates that the `initWithCoder:` validation is going to work.)


/// Convenience macro
///     This mainly servers as an example of the entire 'analysis-chain'. We break it up into many small functions for efficiency – so we can reuse the partial results.
#define classForPropertyName(classobject, propname)                     \
    NSClassFromString(                                                  \
        classNameForProperty(                                           \
            [typeEncodingForProperty(                                   \
                [(classobject) attributesForProperty:(propname)]        \
            ) cStringUsingEncoding:NSUTF8StringEncoding]                \
        )                                                               \
    )                                                                   \

NSString *_Nullable typeEncodingForProperty(NSString *_Nullable propertyAttributes) {
    
    /// Get type encoding for a string obtained with `property_getAttributes()`
    ///     See the Apple docs for an explanation of the attributeString format: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101
    ///     Discussion:
    ///         The docs linked above seem to be outdated. They claim that between the first `T` and `,` of a property's attribute string (obtained with `property_getAttributes()`) you'll find the `@encode()` string of the property's type.
    ///         However, there seems to be a discrepancy, as `@encode()` always just returns `@` for any object, while the property's attribute string will contain additional information about the class and protocols of a given object.
    ///         For example you might find the following substring in the attribute string:`@"T@"NSView<NSSecureCoding><NSCopying>",`. If the docs were accurate this should instead just be `@"T@,`, because `@encode()` just returns `@`.
    
    /// Check nil
    if (propertyAttributes == nil) return nil;
    
    /// Extract the type encoding string
    ///     TODO: Use NSScanner, it's much better suited for this.
    NSInteger typeEncodingPre = [propertyAttributes rangeOfString: @"T" options: NSLiteralSearch].location;
    NSInteger typeEncodingPost = [propertyAttributes rangeOfString: @"," options: NSLiteralSearch].location;
    if (typeEncodingPre == NSNotFound || typeEncodingPost == NSNotFound) {
        assert(false); /// I think this should never happen unless objc runtime is broken or we got a wrong input value
        return nil;
    }
    NSInteger typeEncodingStart = typeEncodingPre + 1;
    NSInteger typeEncodingEnd = typeEncodingPost - 1;
    NSInteger typeEncodingLen = typeEncodingEnd - typeEncodingStart + 1;
    
    if (typeEncodingLen < 0) {
        assert(false); /// Type encoding has less than zero characters. Don't think this can ever happen except if objc runtime is broken or we get wrong input. Think this can only happen if `,` occurs before `T` in the string.
        return nil;
    }
    
    NSRange typeEncodingRange = NSMakeRange(typeEncodingStart, typeEncodingLen);
    NSString *typeEncoding = [propertyAttributes substringWithRange: typeEncodingRange];
    
    /// Return
    return typeEncoding;
}

+ (NSString *_Nullable) attributesForProperty: (NSString *_Nullable)propertyName {
    if (propertyName == nil) return nil;
    objc_property_t property = class_getProperty(self, [propertyName cStringUsingEncoding: NSUTF8StringEncoding]); /// Why UTF8? Quote from Objective-C runtime docs: `All char * in the runtime API should be considered to have UTF-8 encoding.`
    if (property == nil) return nil;
    const char *attributes = property_getAttributes(property);
    if (attributes == NULL) return nil;
    return @(attributes);
}

// MARK: Plist & JSON conversion

/// (Note: [Jan 2025] Disabled the JSON conversion code, since it was unused.
///     When we did wanna create an MFDataClass based on JSON (it was MFLicenseConfig), we wrote a specialized method (it was -[initWithJSONDictionary:]) for that MFDataClass which used these dictionary-encoding methods under-the-hood.
#if 0
    - (NSData *_Nullable)asJSONWithRequireSecureCoding:(BOOL)requireSecureCoding error:(NSError *__autoreleasing _Nullable *_Nullable)errorPtr {
        if (errorPtr) *errorPtr = nil; // Init error
        NSDictionary *dict = [self asPlistWithRequireSecureCoding:requireSecureCoding];
        NSData *result = [NSJSONSerialization dataWithJSONObject:dict options:0 error:errorPtr];
        return result;
    }

    - (instancetype _Nullable)initWithJSON:(NSData *_Nonnull)jsonData requireSecureCoding:(BOOL)requireSecureCoding error:(NSError *__autoreleasing _Nullable * _Nullable)errorPtr {
        if (errorPtr) *errorPtr = nil; /// Init error
        if (!jsonData) return nil;
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:errorPtr];
        if (!dict) return nil;
        self = [self initWithPlist:dict requireSecureCoding:requireSecureCoding error:errorPtr];
        return self;
    }
#endif

- (NSDictionary<NSString *, NSObject *> *_Nonnull) asPlistWithRequireSecureCoding: (BOOL)requireSecureCoding {
    
    /// Converts self to a dictionary by applying "Plist" encoding.
    ///
    /// Why does 'Plist' encoding create an NSDictionary?
    ///     This uses MFPlistEncoder which will convert every node in the object-graph that is not already a plist type to an NSDictionary with string keys. Since MFDataClass instances are not plist types, the root of the object graph (`self`) will be converted to an NSDictionary.
    ///
    /// Alternatives:
    ///     For 'surface-level' dictionary-conversion that doesn't affect the property-values you can use standard KVC methods. Example: `[self dictionaryWithValuesForKeys: [[self class] allPropertyNames]]`
    ///     You can also create a plist object-graph using NSKeyedArchiver instead of MFPlistEncoder, but it won't be easily human readable. See MFPlistEncoder.m
    
    id resultDict = MFEncode(self, requireSecureCoding, kMFEncoding_MFPlist);
    return resultDict;
}

- (instancetype _Nullable) initWithPlist: (NSDictionary<NSString *, NSObject *> *_Nonnull)dict requireSecureCoding: (BOOL)requireSecureCoding {
    
    /// Create an instance from a plist-object-graph.
    ///     If `requireSecureCoding` is enabled, then all of the validation mechanisms from `initWithCoder:` are turned on.
    
    if (!dict) { assert(false); return nil; }
        
    self = (id)MFDecode(dict, requireSecureCoding, MFNSSetMake(self.class), kMFEncoding_MFPlist);
    return self;
}

/// MARK: Property-nullability analysis

+ (BOOL) propertyIsAllowedToBeNil: (NSString *)propertyName {
    
    NSString *nullabilityString = [self rawNullabilityAndTypeOfProperty: propertyName][0];
    BOOL result = [nullabilityString isEqual: @"nullable"];
    
    return result;
    
    /// Notes:
    ///     We used to do more complex stuff here,
    ///         but now we're validating a lot of nullability stuff in `load` making it unnecessary.
    ///
    ///     Here are the old notes from when we did more complex stuff:
    ///     The raw `nullabilityString` can be empty (`@""`).
    ///     The meaning of this is ambiguous:
    ///         For non-nullable types the nullabilityString has to be empty.
    ///         For nullable types, we assume that emptyString means that the property is nullable.
    ///         -> However, this would break if `NS_ASSUME_NONNULL` was set where the MFDataClass was defined. In that case emptyString would mean the property is nonnull, and we couldn't detect this here.
    ///     Update:
    ///         Now, inside `+ load`, we validate that the nullabilityString is empty if and only if the property type does *not* support nullability. For types that support nullability, nullability needs to be specified explicitly. This gets rid of the ambiguity of `@""`, letting us simplify this code a lot.
}

+ (NSArray<NSString *> *_Nullable) rawNullabilityAndTypeOfProperty: (NSString *_Nullable)propertyName {
    ///
    /// Returns a tuple (NSArray) of
    ///     1. stringified version of the nullability attribute
    ///     2. stringified version of the type
    ///      - exactly as they've been passed into the `MFDataClassX(...)` macro.
    ///
    /// Possible outputs for the nullability:
    ///     ```
    ///     - @"nullable"
    ///     - @"nonnull"
    ///     - @"null_resettable"        (Don't use this with MFDataClass)
    ///     - @"null_unspecified"       (Don't use this with MFDataClass)
    ///     - @""                       (We return this if: Nullability was left empty in the property definition)
    ///     - nil                       (We return this if: No property was found for `propertyName`)
    ///     ```
    /// Meta:
    ///     This method gives us all the interesting property info that we cannot get from the objc runtime introspection (from `property_getAttributes()`)
    ///     Specifically, the objc runtime:
    ///     - Doesn't contain any info about nullability
    ///     - Doesn't contain info about lightweight generics. E.g. if the type of a prop is `NSArray<NSNumber *> *`, then the `<NSNumber *>` part is completely invisible to the objc runtime
    ///         (Afaik that's why they are called "lightweight" generics – exactly because they don't interact with the objc runtime.)
    ///
    ///     Because retrieving this stuff at runtime, we just raise an exception / return nil here, and instead override this method inside the `MFDataClassImplementX()` macros.
    ///
    /// On nullable input:
    ///     We use the `propertyName` input value as a dictionary-key in the subclass overrides of this method. When indexing an NSDictionary with nil it just returns nil. So is safe.
    
    [NSException raise: NSInternalInconsistencyException format: @"MFDataClassX(...) macros must override %@ without calling super.", NSStringFromSelector(_cmd)];
    return nil; /// This line will never be reached
}

/// MARK: Property-type analysis

BOOL propertyHasTypeThatSupportsNullability(NSString *_Nullable typeEncoding) {
    
    /// Discussion:
    ///     As far as I know, object pointers and regular pointers support nullability, but nothing else does.
    ///     Object pointers are identified in the type encoding by `@`, while pointers are identified by `^` (or `*` for c strings)
    ///     Interesting/special cases are function pointers (identified by `^?`) and block pointers (identified by `@?`). - those are also nullable. I don't think anything else is.
    ///     Note that opaque types like `CFStringRef` are actually struct pointers, so their type encoding will contain `^`, so this function will also categorize them as 'supports nullability' which is correct.
    
    if (typeEncoding == nil || typeEncoding.length == 0) {
        assert(false);
        return NO;
    }
    
    unichar chars[typeEncoding.length];
    [typeEncoding getCharacters: chars];
    
    unichar c = chars[0];
    if (c == 'r') c = chars[1]; /// Skip lead 'const' encoding. This shouldn't crash except if the typeEncoding is malformed, which we never expect.
    BOOL result = c == '^' || c == '@' || c == '*';
    
    return result;
}

NSString *_Nullable classNameForProperty(const char *_Nullable typeEncoding) {
    
    /// This gets the objc class name for a string obtained with `typeEncodingForProperty()`
    ///
    /// Possible outputs:
    ///     1. The class name for the @property whose type encoding is `typeEncoding`
    ///     2. `@"id"` (if the property is an object of unspecified type)
    ///         (Note that `id` is not a valid class name and will produce nil when passed to `NSClassFromString()`. In contrast, all other non-nil return values should produce valid `Class` object when passed to `NSClassFromString()`)
    ///     3. `nil` (if the property has a non-object type, or no property was found for `propertyName`)
    ///
    ///     Examples:
    ///         - For an *object* property:
    ///             `@property (strong, nonatomic) NSString *coolString;`
    ///             This function would return  `@"NSString"`
    ///
    ///         - For a *non-object* property:
    ///             `@property (assign, nonatomic) int coolInt;`
    ///             This function would return `nil`
    ///
    ///         - For a property with *protocol conformance*:
    ///             `@property (strong, nonatomic) NSObject<NSSecureCoding, NSCopying> *coolCodableObject;`
    ///             This function would strip out the protocol info and return `@"NSObject"`
    ///
    ///         - For a property with unspecified object type (id):
    ///             `@property (strong, nonatomic) id<NSCopying> coolCopyingObject;`
    ///             This function would return `@"id"`
    ///
    /// TODO: Perhaps use NSScanner instead of this low-level c-string stuff
    ///     (Might be easier.)
    
    /// Check NULL
    if (typeEncoding == NULL) { /// `strlen()` segfaults if you pass it NULL
        return nil;
    }
        
    /// Extract the classEncoding from the typeEncoding
    ///     Or return nil if the typeEncoding does not describe a class (If it does describe a class it follows the format `@"..."`)
    long typeEncodingLen = strlen(typeEncoding);
    if (typeEncodingLen < 3) return nil;
    if (typeEncoding[0] != '@' || typeEncoding[1] != '"' || typeEncoding[typeEncodingLen-1] != '"') return nil;
    char classEncoding[typeEncodingLen - 2]; /// The classEncoding buffer will contain the typeEncoding string minus the `@`, `"`, and `"` characters, plus a zero-terminator (`'\0'`)
    strncpy(classEncoding, typeEncoding + 2, typeEncodingLen - 3);
    classEncoding[typeEncodingLen - 3] = '\0';
    
    /// Remove protocol conformance information
    ///     Sidenote:
    ///         Protocol conformance (such as `NSObject<NSSecureCoding> *`) shows up in the `typeEncoding`
    ///         But generic types (such as `NSArray<NSString *> *`) do *not* show up in the `typeEncoding`
    ///         -> even though both use very similar syntax, generics seem to be compile-time-only
    char *protocolInfoStartCharPtr = strchr(classEncoding, '<');
    if (protocolInfoStartCharPtr != NULL) {
        long protocolInfoStartIdx = protocolInfoStartCharPtr - classEncoding;
        classEncoding[protocolInfoStartIdx] = '\0'; /// Cut the string short by inserting a zero-terminator (This is overcomplicated, we could just do `*charPtr = '\0'` to achieve the same thing)
    }
    
    /// Guard empty string
    ///     Empty `classEncoding` means the type is an object of unspecified type
    if (strlen(classEncoding) == 0) return @"id";
    
    /// Validate
    assert(NSClassFromString(@(classEncoding)) != nil);
    
    /// Return
    return @(classEncoding);
}

+ (NSSet<Class> *) classesFromRawTypeStringOfProperty: (NSString *)propName {
    
    /// This is a convenience/cached wrapper around `extractClassesFromRawTypeString()`
    ///     Why parse the tree into a set?
    ///         `extractClassesFromRawTypeString()` returns a tree. We parse it into an NSSet here, since that's what -[NSCoder decodeObjectOfClasses:forKey:] expects.
    ///         We could theoretically use the tree directly, to validate the internal structure of the decoded values.
    ///             But this would require us to hardcode special rules for different generic datatypes. E.g. for `NSDictionary<NSNumber *, NSString *> *`,
    ///             we'd have to hardcode that the decoded value x needs to be an NSDictionary, all elements of [x allKeys] need to be NSNumber, and all elements of [x allValues] need to be NSString.
    ///             > We'd have to manually write different code for every generic type > I don't think it's worth it, especially since automatic validation isn't that useful anyways as explained in MFCoding.m (This calls into question this whole lightweight-generics parsing here. But I guess it was fun.)
    
    /// Get cache
    NSCache *cache      = staticobject([[NSCache alloc] init]);
    NSString *cacheKey  = stringf(@"%@.%@", [self className], propName);
    
    /// Retrieve cached
    id cached = [cache objectForKey: cacheKey];
    if (cached) return cached;
    
    /// Calculate fresh
    NSMutableSet<Class> *result = [[NSMutableSet alloc] init];
    NSString *rawTypeString = [self rawNullabilityAndTypeOfProperty: propName][1];
    TreeNode *tree = extractClassesFromRawTypeString(rawTypeString);
     
    for (TreeNode<Class> *node in tree.depthFirstEnumerator) {
        Class cls = [node representedObject];
        if (cls) [result addObject: cls];
    }
    
    /// Store in cache
    [cache setObject: result forKey: cacheKey];

    /// Return
    return result;
}

TreeNode<Class> *_Nonnull extractClassesFromRawTypeString(NSString *_Nonnull rawTypeString) {
        
    /// Crazy code: Parse `rawTypeString` to get lightweight generics classes.
    ///      ('rawTypeString's are extracted straight from the source code via macros, instead of coming from the objc runtime)
    ///     Explanation/Discussion:
    ///     If we have an MFDataClass property declared with type `NSArray<NSArray<MFLicenseState * > * > *` (matrix of MFLicenseState),
    ///         then we could completely autogenerate NSSecureCoding conformance for that class, if we can extract all the classes from the type string.
    ///         (In the objc runtime this would just show up as `NSArray`, since lightweight <generics> get lost after compilation.)
    ///     Otherwise we have to manually define a list of -[allowedClasses] to make NSSecureCoding decoding work.
    ///
    /// Why not use objc runtime?
    ///     - We need to use macros to get the `rawTypeString`, since the objc runtime typeinfo doesn't contain info about lightweight generics – which we need for this to work.
    ///
    /// Return value format:
    ///     The returned tree cannot be nil, but the values contained in the individual nodes of the tree may be nil if parsing the corresponding section of the rawTypeString into a Class object failed.
    
    if (!rawTypeString || [rawTypeString length] == 0) {
        assert(false);
        return [[TreeNode alloc] initWithRepresentedObject: nil];
    }
        
    /// Declare result
    TreeNode<Class> *result = nil;
        
    /// Declare reusable var
    bool scannerDidScan;
        
    /// Create scanner
    NSScanner *scanner = [NSScanner scannerWithString: rawTypeString];
    
    /// Find topClass
    Class topClass = nil;
    while (1) {
    
        if (scanner.atEnd) break;
        
        /// Find next c identifier
        NSUInteger lastLocation = [scanner scanLocation];
        NSString *skippedChars;
        scannerDidScan = [scanner scanUpToCharactersFromSet: NSCharacterSet.cIdentifierCharacterSet_Start intoString: &skippedChars];
        
        if ([skippedChars containsString: @"<"]) { /// Don't scan past generic specializations.
            /// Discussion: In this case, the topClass is nil, but we'll still try to keep parsing the generic specialization – I guess for robustness/debugging.
            [scanner setScanLocation: lastLocation];
            break;
        }
        
        if (scanner.atEnd) break;
        
        /// Parse found c identifier
        NSString *identifier = nil;
        scannerDidScan = [scanner scanCharactersFromSet: NSCharacterSet.cIdentifierCharacterSet_Continue intoString: &identifier]; /// This assumes that `_Continue` is a   superset of `_Start`.
        Class cls = nil;
        if (identifier && (cls = NSClassFromString(identifier))) { /// Find first identifier that is a valid class name. This makes us skip keywords like `const` or `__kindof` that can appear before the class name.
            topClass = cls;
            break;
        }
    }
        
    /// Create tree node
    result = [[TreeNode alloc] initWithRepresentedObject: topClass];
    
    /// Parse generic specializations
    ///     Note: Since the syntax for protocols and generics is the same (< ... > ), this will also catch protocols.
    ///     But then NSClassFromString() should fail on the protocols name and the tree node for the protocol should end up containing nil – which is fine.
    
    NSMutableArray<NSString *> *specializations = [NSMutableArray array];
    do {
        
        if (scanner.atEnd) break;
        scannerDidScan = [scanner scanUpToString: @"<" intoString: nil]; /// Skip everything between the topClass and the generic specialization
        if (scanner.atEnd) break;
        
        ({
            
            unichar chars[rawTypeString.length]; /// Put the string on the stack for convenience and speed (?)
            [rawTypeString getCharacters: chars];
        
            int bracketBalance = 0;
            NSUInteger i, j;
            i = j = scanner.scanLocation;
            
            for ( ;; j++) {
                
                if (j >= arrcount(chars)) { assert(false); break; } /// Failsafe so we don't infinite-loop/segfault
                
                if      (chars[j] == '<')  bracketBalance++; /// Guaranteed to hit this during first iteration.
                else if (chars[j] == '>')  bracketBalance--;
                
                else if (chars[j] == ',' && bracketBalance == 1) {
                    [specializations addObject: [rawTypeString substringWithRange: rangefromto(i+1, j-1)]];
                    i = j;
                }
                if (bracketBalance <= 0) {
                    [specializations addObject: [rawTypeString substringWithRange: rangefromto(i+1, j-1)]];
                    break;
                }
            }
            
            assert(bracketBalance == 0);
        });
        
    } while (0);
    
    /// Recurse
    ///     Note: We expect 1 specializations for NSArray, and 2 for NSDictionary. I've never seen 3 or more.
    for (NSString *spec in specializations) {
        TreeNode *child = extractClassesFromRawTypeString(spec);
        [[result mutableChildNodes] addObject: child];
    }
    
    /// Return
    return result;
}

@end

#define MF_TEST 0

#if MF_TEST
    @interface MFDataClass_RandomLoadTests : NSObject @end
    @implementation MFDataClass_RandomLoadTests

    + (void)load {
        __attribute__((unused))
            const NSDictionary<NSDictionary<NSString *, __kindof NSArray<NSString *> *> *, NSArray<const NSDate *> *> *const
            aaa = nil;
        NSString  *typeStr = @"const NSDictionary<NSDictionary<NSString *,NSArray<NSStringgggg *> *> *,NSArray<const NSDate *>*>*const";
        NSString  *typeStr_nospace = @"NSDictionary<NSDictionary<NSString,NSArray<NSString>>,NSArray<NSDate>>const";
        TreeNode *parsed = parseRawTypeString(typeStr);
        TreeNode *parsed_nospace = parseRawTypeString(typeStr_nospace);
        NSLog(@"TEST: parsed rawTypeString:\n%@\nnospace:\n%@", parsed, parsed_nospace);
    }
    @end
#endif
